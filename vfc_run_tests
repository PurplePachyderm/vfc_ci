#!/usr/bin/env python3

# This script reads the vfc_tests_config.json and executes the tests accordingly
# It will also generate a ... .vfcrun.json file with the results of the run

import os
import json
import glob

import sys

import calendar
import time

import pandas as pd
import numpy as np

import base64
import struct


    # Helper functions that reads a probes CSV files

def read_probes_csv(filepath, backend):

    results = pd.read_csv(filepath)

    # NOTE The lambda function should probably change depending on if the system
    # uses little or big endian
    results["value"] = results["value"].apply(lambda x: struct.unpack('<d'.format(64.0), base64.standard_b64decode(x))[0])

    results = results.groupby("key").value.apply(list).reset_index()
    results[["test", "variable"]] = results["key"].str.split(':', expand=True)

    del results["key"]
    results.rename(columns = {"value":"values"}, inplace = True)

    results["backend"] = backend

    return results


    # Open and read the tests config file

try:
    with open("vfc_tests_config.json", "r") as file:
        data = file.read()

except FileNotFoundError as e:
    e.strerror = "This file is required to describe the tests to run and generate a Verificarlo run file"
    raise e

config = json.loads(data)


    # Check the "--is-git-commit" argument
    # (and if detected, get last commit's metadata)

# Default value is the current timestamp. If the run is associated with a git commit,
# it will be replaced by the commit's timestamp.
timestamp = calendar.timegm(time.gmtime())

commit_metadata = {}
is_git_commit = False

if len(sys.argv) > 1:
    if sys.argv[1] == "--is-git-commit":
        print("Fetching metadata from last commit...")
        from git import Repo

        is_git_commit = True

        repo = Repo(".")
        head_commit = repo.head.commit

        timestamp = head_commit.authored_date

        commit_metadata["hash"] = str(head_commit)[0:7]
        commit_metadata["author"] = str(head_commit.author) + " <" + head_commit.author.email + ">"
        commit_metadata["message"] = head_commit.message


    # Initialize the vfcrun object that will be exported

vfcrun = {
    "timestamp": timestamp,

    "is_git_commit": is_git_commit,
    "commit_metadata": commit_metadata,

    "results": []
}


    # Run the build command

print("Building tests...")
os.system(config["make_command"])


    # Execute all tests and collect results in a Pandas dataframe

values = [] # This is an array of Pandas dataframes for now

for executable in config["executables"]:
    print("Running executable :", executable["executable"], "...")

    parameters = ""
    if "parameters" in executable:
        parameters = executable["parameters"]

    for backend in executable["vfc_backends"]:
        print("    ... with backend :", backend["name"])

        export_backend = 'VFC_BACKENDS="' + backend["name"] + '" '
        command = "./" + executable["executable"] + " " + parameters

        repetitions = 1
        if "repetitions" in backend:
            repetitions = backend["repetitions"]

        # Run test repetitions and save results
        for i in range(repetitions):
            os.system(export_backend + command)

            # List and read all the output files
            output_files = glob.glob(executable['output_files'])

            for file in output_files:
                values.append(read_probes_csv(file, backend["name"]))

values = pd.concat(values, sort=False, ignore_index=True)


    # Compute statistics for each variable of each test (over combined dataframe)

# TODO


    # Export the vfcrun object as a JSON file

if is_git_commit:
    file_name = commit_metadata["hash"] + ".vfcrun.json"

else:
    file_name = str(timestamp) + ".vfcrun.json"

print("\nRun succesful, exporting results in", file_name)

with open(file_name, 'w', encoding='utf8') as f:
    json.dump(vfcrun, f, ensure_ascii=False)
