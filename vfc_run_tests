#!/usr/bin/env python3

# This script reads the vfc_tests_config.json and executes the tests accordingly
# It will also generate a ... .vfcrun.json file with the results of the run

import os
import json
import glob

import sys

import calendar
import time

import pandas as pd
import numpy as np

import base64
import struct



    # Helper functions that reads a probes CSV files

def read_probes_csv(filepath, backend):

    results = pd.read_csv(filepath)

    # NOTE The lambda function should probably change depending on if the system
    # uses little or big endian
    results["value"] = results["value"].apply(lambda x: float.fromhex(x))

    results = results.groupby("key").value.apply(list).reset_index()
    results[["test", "variable"]] = results["key"].str.split(':', expand=True)

    del results["key"]
    results.rename(columns = {"value":"values"}, inplace = True)

    results["vfc_backend"] = backend

    return results



    # Open and read the tests config file

try:
    with open("vfc_tests_config.json", "r") as file:
        data = file.read()

except FileNotFoundError as e:
    e.strerror = "This file is required to describe the tests to run and generate a Verificarlo run file"
    raise e

config = json.loads(data)



    # Set up the commit metadata (if any)

# Commit metadata is initiated as if no commit was associated
commit_metadata = {
    "timestamp": calendar.timegm(time.gmtime()),
    "is_git_commit": False
}

if len(sys.argv) > 1:
    if sys.argv[1] == "--is-git-commit":
        print("Fetching metadata from last commit...")
        from git import Repo

        commit_metadata["is_git_commit"] = True

        repo = Repo(".")
        head_commit = repo.head.commit

        commit_metadata["timestamp"] = head_commit.authored_date

        commit_metadata["hash"] = str(head_commit)[0:7]
        commit_metadata["author"] = str(head_commit.author) + " <" + head_commit.author.email + ">"
        commit_metadata["message"] = head_commit.message



    # Run the build command

print("Building tests...")
os.system(config["make_command"])


    # Execute all tests and collect results in a Pandas dataframe

values = [] # This is an array of Pandas dataframes for now

for executable in config["executables"]:
    print("Running executable :", executable["executable"], "...")

    parameters = ""
    if "parameters" in executable:
        parameters = executable["parameters"]

    for backend in executable["vfc_backends"]:

        export_backend = 'VFC_BACKENDS="' + backend["name"] + '" '
        command = "./" + executable["executable"] + " " + parameters

        repetitions = 1
        if "repetitions" in backend:
            repetitions = backend["repetitions"]

        # Run test repetitions and save results
        for i in range(repetitions):
            os.system(export_backend + command)

            # List and read all the output files
            output_files = glob.glob(executable['output_files'])

            for file in output_files:
                values.append(read_probes_csv(file, backend["name"]))

# Combine all separate executions in one dataframe
values = pd.concat(values, sort=False, ignore_index=True)



    # Data processing

print("Processing data...")

def numpy_float_array(x):
    return np.array(x).astype(float)

def get_quantile(array, p):
    return np.quantile(array, p)

values["values"] = values["values"].apply(numpy_float_array)

values["mu"] = values["values"].apply(np.average)
values["sigma"] = values["values"].apply(np.std)

# NOTE : What about s when the sample's avg is 0 ? (divison by 0 returns NaN)
values["s10"] = - np.log10(np.absolute( values["sigma"] / values["mu"] ))
values["s2"] = - np.log2(np.absolute( values["sigma"] / values["mu"] ))

# NOTE : Would sorting values["values"] before getting the quantiles give
# better performances ?
values["quantile10"] = values["values"].apply(get_quantile, args=(0.1,))
values["quantile50"] = values["values"].apply(get_quantile, args=(0.5,))
values["quantile90"] = values["values"].apply(get_quantile, args=(0.9,))

# Delete the raw values
# NOTE In the future, we might want to export these values in a way or another
del values["values"]
values = values.set_index(["test", "vfc_backend", "variable"])


    # Concatenate data and metadata, then export to hdf5

print("commit_metadata = ")
print(commit_metadata)

print("values = ")
print(values)
